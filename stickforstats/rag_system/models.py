import uuid
from django.db import models
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.db.models import JSONField

User = get_user_model()

class Document(models.Model):
    """
    Model for storing documents used in the RAG system.
    Documents can be instructions, educational content, examples, etc.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    title = models.CharField(max_length=255)
    content = models.TextField()
    document_type = models.CharField(max_length=100)  # Type: 'instruction', 'education', 'example', etc.
    module = models.CharField(max_length=100, blank=True, null=True)  # Which module this document relates to
    topic = models.CharField(max_length=100, blank=True, null=True)  # Topic: 'confidence_intervals', 'anova', etc.
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    metadata = JSONField(default=dict)
    
    class Meta:
        ordering = ['document_type', 'module', 'topic', 'title']
        
    def __str__(self):
        return f"{self.title} ({self.document_type})"

class DocumentChunk(models.Model):
    """
    Model for storing document chunks with their embeddings.
    Each Document may be split into multiple chunks for embedding and retrieval.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    document = models.ForeignKey(Document, on_delete=models.CASCADE, related_name='chunks')
    content = models.TextField()
    chunk_index = models.IntegerField()
    embedding = models.BinaryField(null=True)  # Embedding stored as binary
    embedding_model = models.CharField(max_length=100, blank=True, null=True)  # Which model generated the embedding
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['document', 'chunk_index']
        unique_together = [['document', 'chunk_index']]
        
    def __str__(self):
        return f"{self.document.title} - Chunk {self.chunk_index}"

class UserQuery(models.Model):
    """
    Model for storing user queries and interactions with the RAG system.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='queries')
    query_text = models.TextField()
    query_context = JSONField(default=dict)  # Context info like current module, dataset, etc.
    embedding = models.BinaryField(null=True)  # Query embedding stored as binary
    created_at = models.DateTimeField(default=timezone.now)
    relevance_score = models.FloatField(null=True, blank=True)  # Score from retrieval
    
    class Meta:
        ordering = ['-created_at']
        
    def __str__(self):
        return f"Query by {self.user.username}: {self.query_text[:50]}..."

class RetrievedDocument(models.Model):
    """
    Model for storing documents retrieved in response to a user query.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    query = models.ForeignKey(UserQuery, on_delete=models.CASCADE, related_name='retrieved_documents')
    document_chunk = models.ForeignKey(DocumentChunk, on_delete=models.CASCADE, related_name='retrievals')
    retrieval_score = models.FloatField()  # Similarity score from retrieval
    rank = models.IntegerField()  # Rank in the retrieval results
    created_at = models.DateTimeField(default=timezone.now)
    
    class Meta:
        ordering = ['query', 'rank']
        
    def __str__(self):
        return f"Retrieved for {self.query.query_text[:30]}... - Rank {self.rank}"

class GeneratedResponse(models.Model):
    """
    Model for storing responses generated by the LLM.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    query = models.ForeignKey(UserQuery, on_delete=models.CASCADE, related_name='responses')
    response_text = models.TextField()
    model_used = models.CharField(max_length=100)  # Which LLM was used
    prompt = models.TextField()  # The full prompt sent to the model
    created_at = models.DateTimeField(default=timezone.now)
    generation_params = JSONField(default=dict)  # Parameters used for generation
    feedback = JSONField(default=dict)  # User feedback on response
    
    class Meta:
        ordering = ['-created_at']
        
    def __str__(self):
        return f"Response to {self.query.query_text[:30]}..."

class Conversation(models.Model):
    """
    Model for storing conversation history and context.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='conversations')
    title = models.CharField(max_length=255)
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    context = JSONField(default=dict)  # Additional context for the conversation
    
    class Meta:
        ordering = ['-updated_at']
        
    def __str__(self):
        return f"Conversation: {self.title} ({self.user.username})"

class ConversationMessage(models.Model):
    """
    Model for storing messages in a conversation.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='messages')
    user_message = models.TextField(blank=True, null=True)  # User's message
    system_message = models.TextField(blank=True, null=True)  # System's response
    query = models.ForeignKey(UserQuery, on_delete=models.SET_NULL, null=True, blank=True, related_name='conversation_messages')
    response = models.ForeignKey(GeneratedResponse, on_delete=models.SET_NULL, null=True, blank=True, related_name='conversation_messages')
    created_at = models.DateTimeField(default=timezone.now)
    message_index = models.IntegerField()  # Order in the conversation
    
    class Meta:
        ordering = ['conversation', 'message_index']
        unique_together = [['conversation', 'message_index']]
        
    def __str__(self):
        return f"Message {self.message_index} in {self.conversation.title}"